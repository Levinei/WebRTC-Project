<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lightweight chat and text</title>
    
    <!-- PeerJS Library - Handles WebRTC signaling for us (replaces Node.js server) -->
    <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>
    
    <style>
        /* ================================================================
           GLOBAL STYLES
           These are the base styles applied to all elements
           ================================================================ */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow: hidden;
        }

        /* ================================================================
           HOME SCREEN STYLES
           The initial screen where users enter username and create/join rooms
           ================================================================ */
        
        #home-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }

        .home-container {
            background: white;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 100%;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            text-align: center;
            font-size: 28px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .input-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 600;
            font-size: 14px;
        }

        input[type="text"] {
            width: 100%;
            padding: 14px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 15px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 30px;
        }

        button {
            padding: 16px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #28a745;
            color: white;
        }

        .btn-secondary:hover {
            background: #218838;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }

        /* ================================================================
           ROOM SETUP SCREEN STYLES
           Shown after creating a room, displays the room ID and allows naming
           ================================================================ */
        
        #room-setup-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }

        .setup-container {
            background: white;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 100%;
        }

        /* Room ID display box - shows the 10-digit room code */
        .room-id-display {
            background: #f0f8ff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            text-align: center;
        }

        .room-id-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
        }

        .room-id-value {
            font-size: 32px;
            font-weight: bold;
            color: #667eea;
            letter-spacing: 2px;
            font-family: 'Courier New', monospace;
        }

        .copy-instruction {
            font-size: 12px;
            color: #888;
            margin-top: 8px;
        }

        /* ================================================================
           JOIN ROOM MODAL
           Popup that appears when user clicks "Join Room" button
           ================================================================ */
        
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            max-width: 400px;
            width: 90%;
        }

        .modal-header {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }

        .modal-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }

        .btn-cancel {
            background: #dc3545;
            color: white;
        }

        .btn-cancel:hover {
            background: #c82333;
        }

        /* ================================================================
           ROOM SCREEN STYLES (MAIN APP)
           The main application interface with channels, chat, and users
           ================================================================ */
        
        #room-screen {
            display: none;
            height: 100vh;
            background: #2c2f33;
        }

        /* 3-column grid layout: channels | chat | users */
        .room-layout {
            display: grid;
            grid-template-columns: 200px 1fr 250px;
            grid-template-rows: 50px 1fr 70px;
            height: 100vh;
            gap: 0;
        }

        /* ================================================================
           TOP HEADER BAR
           Shows the room name at the top of the screen
           ================================================================ */
        .room-header {
            grid-column: 1 / -1;
            background: #23272a;
            padding: 0 20px;
            display: flex;
            align-items: center;
            border-bottom: 2px solid #1a1c1f;
        }

        .room-title {
            color: white;
            font-size: 18px;
            font-weight: 600;
        }

        /* ================================================================
           LEFT SIDEBAR - VOICE CHANNELS
           List of voice channels that users can switch between
           ================================================================ */
        .channels-panel {
            grid-row: 2;
            background: #2f3136;
            border-right: 1px solid #202225;
            overflow-y: auto;
        }

        .channels-header {
            padding: 15px;
            background: #27292d;
            color: white;
            font-weight: 600;
            font-size: 14px;
            border-bottom: 1px solid #202225;
        }

        .channel-list {
            padding: 10px;
        }

        /* Individual channel item styling */
        .channel-item {
            padding: 10px 12px;
            margin-bottom: 5px;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: #8e9297;
            font-size: 14px;
            transition: all 0.2s;
        }

        .channel-item:hover {
            background: #34373c;
            color: #dcddde;
        }

        /* Active channel gets highlighted */
        .channel-item.active {
            background: #5865f2;
            color: white;
        }

        .channel-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Delete button (Ã—) appears on hover for host */
        .channel-delete {
            color: #ed4245;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .channel-item:hover .channel-delete {
            opacity: 1;
        }

        .channel-delete:hover {
            background: #ed4245;
            color: white;
        }

        /* Button to add new channels */
        .add-channel-btn {
            width: 100%;
            padding: 12px;
            background: #3ba55d;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            transition: background 0.2s;
            margin-top: 10px;
        }

        .add-channel-btn:hover {
            background: #2d7d46;
        }

        /* ================================================================
           CENTER PANEL - CHAT AREA
           Where messages are displayed and typed
           ================================================================ */
        .chat-panel {
            grid-row: 2;
            display: flex;
            flex-direction: column;
            background: #36393f;
        }

        /* Scrollable area for chat messages */
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        /* Individual chat message bubble */
        .chat-message {
            margin-bottom: 15px;
            padding: 10px;
            background: #40444b;
            border-radius: 8px;
            word-wrap: break-word;
        }

        /* Message header with username and timestamp */
        .message-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        }

        .message-username {
            color: #5865f2;
            font-weight: 600;
            font-size: 14px;
        }

        /* Timestamp showing hh:mm:ss AM/PM */
        .message-timestamp {
            color: #72767d;
            font-size: 11px;
        }

        .message-text {
            color: #dcddde;
            font-size: 14px;
            line-height: 1.4;
        }

        /* Links in messages are clickable and blue */
        .message-text a {
            color: #00aff4;
            text-decoration: underline;
        }

        /* Embedded images/GIFs in messages */
        .message-text img {
            max-width: 300px;
            border-radius: 5px;
            margin-top: 8px;
            display: block;
        }

        /* Input area at bottom of chat */
        .chat-input-area {
            padding: 15px 20px;
            background: #40444b;
            border-top: 1px solid #2f3136;
        }

        .chat-input {
            width: 100%;
            padding: 12px 15px;
            background: #36393f;
            border: 1px solid #202225;
            border-radius: 8px;
            color: #dcddde;
            font-size: 14px;
        }

        .chat-input:focus {
            outline: none;
            border-color: #5865f2;
        }

        /* ================================================================
           RIGHT SIDEBAR - USERS LIST
           Shows all members in the current voice channel
           ================================================================ */
        .users-panel {
            grid-row: 2;
            background: #2f3136;
            border-left: 1px solid #202225;
            overflow-y: auto;
        }

        .users-header {
            padding: 15px;
            background: #27292d;
            color: white;
            font-weight: 600;
            font-size: 14px;
            border-bottom: 1px solid #202225;
        }

        .user-list {
            padding: 10px;
        }

        /* Individual user item in the list */
        .user-item {
            padding: 8px 12px;
            margin-bottom: 5px;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #dcddde;
            font-size: 14px;
            transition: background 0.2s;
            position: relative;
        }

        .user-item:hover {
            background: #34373c;
        }

        /* Mute status icon (ðŸ”Š or ðŸ”‡) */
        .user-status-icon {
            font-size: 12px;
        }

        .user-name {
            flex: 1;
        }

        /* ================================================================
           USER CONTEXT MENU
           Right-click menu for muting/adjusting individual user volumes
           ================================================================ */
        .user-context-menu {
            display: none;
            position: fixed;
            background: #18191c;
            border: 1px solid #0f1012;
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            z-index: 1000;
            min-width: 200px;
        }

        .user-context-menu.active {
            display: block;
        }

        .context-menu-item {
            padding: 10px 12px;
            color: #dcddde;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            transition: background 0.2s;
        }

        .context-menu-item:hover {
            background: #4752c4;
        }

        /* Volume slider in the context menu */
        .volume-control {
            padding: 12px;
        }

        .volume-label {
            color: #b9bbbe;
            font-size: 12px;
            margin-bottom: 8px;
        }

        .volume-slider {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #4f545c;
            outline: none;
            -webkit-appearance: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #5865f2;
            cursor: pointer;
        }

        .volume-value {
            color: #b9bbbe;
            font-size: 11px;
            text-align: center;
            margin-top: 4px;
        }

        /* ================================================================
           BOTTOM CONTROLS BAR
           Contains Leave, Settings, and Mic buttons
           ================================================================ */
        .controls-bar {
            grid-column: 1 / -1;
            background: #23272a;
            border-top: 2px solid #1a1c1f;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }

        .controls-left, .controls-right {
            display: flex;
            gap: 15px;
        }

        .control-btn {
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .control-btn.btn-settings {
            background: #4f545c;
            color: white;
        }

        .control-btn.btn-settings:hover {
            background: #686d73;
        }

        .control-btn.btn-mic {
            background: #5865f2;
            color: white;
        }

        .control-btn.btn-mic:hover {
            background: #4752c4;
        }

        .control-btn.btn-leave {
            background: #ed4245;
            color: white;
        }

        .control-btn.btn-leave:hover {
            background: #c23235;
        }

        /* ================================================================
           SETTINGS MODAL
           Popup for configuring audio, PTT, and noise suppression
           ================================================================ */
        .settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .settings-modal.active {
            display: flex;
        }

        .settings-content {
            background: #36393f;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            max-width: 500px;
            width: 90%;
            color: #dcddde;
        }

        .settings-header {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 25px;
            color: white;
        }

        .setting-item {
            margin-bottom: 25px;
        }

        .setting-label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            font-size: 14px;
            color: #b9bbbe;
        }

        select {
            width: 100%;
            padding: 12px;
            background: #2f3136;
            border: 1px solid #202225;
            border-radius: 8px;
            color: #dcddde;
            font-size: 14px;
        }

        select:focus {
            outline: none;
            border-color: #5865f2;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        /* Push-to-talk key capture box */
        .ptt-keybox {
            width: 100%;
            padding: 12px;
            background: #2f3136;
            border: 2px solid #5865f2;
            border-radius: 8px;
            color: #dcddde;
            text-align: center;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
        }

        .ptt-keybox:hover {
            background: #34373c;
        }

        .settings-footer {
            margin-top: 30px;
            display: flex;
            justify-content: flex-end;
        }

        /* ================================================================
           SCROLLBAR STYLING
           Custom scrollbar for dark theme
           ================================================================ */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #2e3136;
        }

        ::-webkit-scrollbar-thumb {
            background: #202225;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #18191c;
        }
    </style>
</head>
<body>
    <!-- ================================================================
         HOME SCREEN
         Initial screen where users enter their username and choose to
         create a new room or join an existing one
         ================================================================ -->
    
    <div id="home-screen">
        <div class="home-container">
            <h1>Levie's lightweight chat and text app</h1>
            <p class="subtitle">Connect with friends through voice</p>
            
            <!-- Username input - required field -->
            <div class="input-group">
                <label for="username">Username <span style="color: red;">*</span></label>
                <input type="text" id="username" placeholder="Enter your username">
            </div>
            
            <!-- Create Room and Join Room buttons -->
            <div class="button-group">
                <button class="btn-primary" id="create-room-btn">Create Room</button>
                <button class="btn-secondary" id="join-room-btn">Join Room</button>
            </div>
        </div>
    </div>

    <!-- ================================================================
         ROOM SETUP SCREEN
         Appears after creating a room - shows the generated 10-digit
         room ID and allows the host to name the room
         ================================================================ -->
    
    <div id="room-setup-screen">
        <div class="setup-container">
            <h1>Room Created!</h1>
            <p class="subtitle">Share this Room ID with others</p>
            
            <!-- Display the 10-digit room ID (clickable to copy) -->
            <div class="room-id-display">
                <div class="room-id-label">ROOM ID</div>
                <div class="room-id-value" id="display-room-id">0000000000</div>
                <div class="copy-instruction">Click to copy</div>
            </div>
            
            <!-- Room name input - required -->
            <div class="input-group">
                <label for="room-name-input">Room Name <span style="color: red;">*</span></label>
                <input type="text" id="room-name-input" placeholder="Enter room name">
            </div>
            
            <button class="btn-primary" id="enter-room-btn" style="width: 100%;">Enter Room</button>
        </div>
    </div>

    <!-- ================================================================
         JOIN ROOM MODAL
         Popup that appears when clicking "Join Room" button
         User enters the 10-digit room ID here
         ================================================================ -->
    
    <div class="modal-overlay" id="join-modal">
        <div class="modal-content">
            <div class="modal-header">Join Room</div>
            <div class="input-group">
                <label for="join-room-id">Room ID <span style="color: red;">*</span></label>
                <input type="text" id="join-room-id" placeholder="Enter 10-digit room ID" maxlength="10">
            </div>
            <div class="modal-buttons">
                <button class="btn-cancel" id="cancel-join-btn">Cancel</button>
                <button class="btn-primary" id="confirm-join-btn">Join</button>
            </div>
        </div>
    </div>

    <!-- ================================================================
         ROOM SCREEN (MAIN APPLICATION)
         The main voice chat interface with 3 panels:
         - Left: Voice channels
         - Center: Chat messages
         - Right: Users list
         ================================================================ -->
    
    <div id="room-screen">
        <div class="room-layout">
            <!-- Top header bar showing room name and room ID -->
            <div class="room-header">
                <div class="room-title" id="room-title-display">Room Name</div>
                <div style="margin-left: auto; color: #b9bbbe; font-size: 14px;">
                    Room ID: <span id="header-room-id" style="color: #5865f2; font-weight: bold; cursor: pointer;" title="Click to copy">0000000000</span>
                </div>
            </div>
            
            <!-- Left sidebar - Voice channels list -->
            <div class="channels-panel">
                <div class="channels-header">VOICE CHANNELS</div>
                <div class="channel-list" id="channel-list">
                    <!-- Channels will be dynamically added here by JavaScript -->
                </div>
                <!-- Button to create new channel (host only) -->
                <button class="add-channel-btn" id="add-channel-btn">+</button>
            </div>
            
            <!-- Center panel - Chat messages and input -->
            <div class="chat-panel">
                <div class="chat-messages" id="chat-messages">
                    <!-- Chat messages appear here dynamically -->
                </div>
                <div class="chat-input-area">
                    <input type="text" class="chat-input" id="chat-input" placeholder="Type a message...">
                </div>
            </div>
            
            <!-- Right sidebar - Users in current channel -->
            <div class="users-panel">
                <div class="users-header">MEMBERS</div>
                <div class="user-list" id="user-list">
                    <!-- Users will be added here dynamically -->
                </div>
            </div>
            
            <!-- Bottom control bar with Settings, Mic, and Leave buttons -->
            <div class="controls-bar">
                <div class="controls-left">
                    <button class="control-btn btn-settings" id="settings-btn">Settings</button>
                    <button class="control-btn btn-mic" id="mic-btn">Mic</button>
                </div>
                <div class="controls-right">
                    <button class="control-btn btn-leave" id="leave-btn">Leave</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ================================================================
         USER CONTEXT MENU
         Right-click menu that appears when clicking on a user
         Allows muting and adjusting volume for that specific user
         ================================================================ -->
    <div class="user-context-menu" id="user-context-menu">
        <div class="context-menu-item" id="toggle-mute-user">Mute/Unmute</div>
        <div class="volume-control">
            <div class="volume-label">User Volume</div>
            <!-- Slider to adjust individual user's volume (0-200%) -->
            <input type="range" class="volume-slider" id="user-volume-slider" min="0" max="200" value="100">
            <div class="volume-value" id="user-volume-value">100%</div>
        </div>
    </div>

    <!-- ================================================================
         SETTINGS MODAL
         Popup for configuring all audio and input settings
         ================================================================ -->
    <div class="settings-modal" id="settings-modal">
        <div class="settings-content">
            <div class="settings-header">Settings</div>
            
            <!-- Microphone device selection dropdown -->
            <div class="setting-item">
                <label class="setting-label">Microphone Input</label>
                <select id="mic-input-select">
                    <option>Loading...</option>
                </select>
            </div>
            
            <!-- Input volume slider (0-100%) -->
            <div class="setting-item">
                <label class="setting-label">Input Volume</label>
                <input type="range" class="volume-slider" id="input-volume-slider" min="0" max="100" value="100">
                <div class="volume-value" id="input-volume-value">100%</div>
            </div>
            
            <!-- Output volume slider (0-200%) for all incoming audio -->
            <div class="setting-item">
                <label class="setting-label">Output Volume</label>
                <input type="range" class="volume-slider" id="output-volume-slider" min="0" max="200" value="100">
                <div class="volume-value" id="output-volume-value">100%</div>
            </div>
            
            <!-- Noise suppression toggle -->
            <div class="setting-item">
                <div class="checkbox-container">
                    <input type="checkbox" id="noise-suppression-checkbox">
                    <label class="setting-label" style="margin: 0;">Enable Noise Suppression</label>
                </div>
            </div>
            
            <!-- Push-to-talk configuration -->
            <div class="setting-item">
                <div class="checkbox-container">
                    <input type="checkbox" id="ptt-checkbox">
                    <label class="setting-label" style="margin: 0;">Enable Push-to-Talk</label>
                </div>
                <!-- Hidden section that appears when PTT is enabled -->
                <div id="ptt-key-section" style="display: none;">
                    <div class="ptt-keybox" id="ptt-keybox">Click here to capture Push to talk input key</div>
                </div>
            </div>
            
            <div class="settings-footer">
                <button class="control-btn btn-primary" id="close-settings-btn">Close</button>
            </div>
        </div>
    </div>

    <script>
        // ====================================================================
        // GLOBAL VARIABLES AND STATE
        // These variables store the application's state throughout runtime
        // ====================================================================
        
        let peer; // PeerJS peer object - our connection to the PeerJS signaling server
        let myPeerId; // Our unique peer ID assigned by PeerJS
        let localStream; // Our microphone audio stream
        let currentUsername = ''; // Username entered by user
        let currentRoomId = ''; // The 10-digit room ID we're in
        let currentRoomName = ''; // The room name
        let currentChannelId = ''; // Current voice channel ID
        let currentChannelName = ''; // Current voice channel name
        let isHost = false; // Whether we're the room host
        
        // Room data - now synchronized via peer-to-peer messages
        // Structure: { roomName, host, channels: { channelId: { name, users: [] } } }
        let roomData = {};
        
        // WebRTC connections
        let peerConnections = {}; // Stores call objects for each peer
        let dataConnections = {}; // Stores PeerJS data connections for chat
        let remoteAudioElements = {}; // Stores <audio> elements for remote users
        
        // Settings (stored in localStorage)
        let selectedMicDeviceId = null;
        let inputVolume = 100;
        let outputVolume = 100;
        let noiseSuppressionEnabled = false;
        let pushToTalkEnabled = false;
        let pushToTalkKey = null; // Stores the PTT key/button binding
        let isPushToTalkActive = false;
        let userVolumes = {}; // Individual volume settings per user
        
        // Context menu state
        let contextMenuTargetUserId = null;
        
        // Channel users tracking
        let usersInChannel = {}; // Map of peerId -> username in current channel
        
        // Connection to room host (for non-hosts to sync room data)
        let hostConnection = null;
        
        // ====================================================================
        // INITIALIZATION
        // Code that runs when the page first loads
        // ====================================================================
        
        window.addEventListener('DOMContentLoaded', () => {
            // Load saved username from browser's localStorage
            const savedUsername = localStorage.getItem('username');
            if (savedUsername) {
                document.getElementById('username').value = savedUsername;
            }
            
            // Load all saved settings (mic, volumes, PTT, etc.)
            loadSettings();
        });
        
        // ====================================================================
        // HOME SCREEN - CREATE ROOM BUTTON
        // When user clicks "Create Room", generate a 10-digit room ID
        // The host's peer ID IS the room ID, so others can connect directly
        // ====================================================================
        
        document.getElementById('create-room-btn').addEventListener('click', async () => {
            const username = document.getElementById('username').value.trim();
            
            // Validate username is not empty
            if (!username) {
                alert('Please enter a username');
                return;
            }
            
            currentUsername = username;
            localStorage.setItem('username', username); // Save for next time
            
            // Generate unique 10-digit room ID - this will be the host's peer ID
            currentRoomId = generateRoomId();
            
            // Initialize PeerJS connection with the room ID as our peer ID
            // This allows others to connect to us by knowing the room ID
            peer = new Peer(currentRoomId, {
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                }
            });
            
            // Wait for PeerJS connection to open
            peer.on('open', (id) => {
                myPeerId = id;
                console.log('My peer ID (Room ID):', myPeerId);
                
                // We are the host since we created the room
                isHost = true;
                
                // Create default room structure
                const defaultChannelId = generateChannelId();
                roomData = {
                    roomName: 'Unnamed Room', // Will be set later
                    host: myPeerId,
                    channels: {
                        [defaultChannelId]: {
                            name: 'Voice Channel 1',
                            users: [{ peerId: myPeerId, username: currentUsername }]
                        }
                    }
                };
                
                currentChannelId = defaultChannelId;
                currentChannelName = 'Voice Channel 1';
                
                // Setup PeerJS event listeners
                setupPeerListeners();
                
                // Show room setup screen
                document.getElementById('home-screen').style.display = 'none';
                document.getElementById('room-setup-screen').style.display = 'flex';
                document.getElementById('display-room-id').textContent = currentRoomId;
            });
            
            // Handle PeerJS errors
            peer.on('error', (error) => {
                console.error('Peer error:', error);
                if (error.type === 'unavailable-id') {
                    alert('This room ID is already in use. Please try creating a new room.');
                } else {
                    alert('Connection error: ' + error.type);
                }
            });
        });
        
        // ====================================================================
        // HOME SCREEN - JOIN ROOM BUTTON
        // Shows the modal for entering a room ID
        // ====================================================================
        
        document.getElementById('join-room-btn').addEventListener('click', () => {
            const username = document.getElementById('username').value.trim();
            
            if (!username) {
                alert('Please enter a username');
                return;
            }
            
            // Show the join room modal
            document.getElementById('join-modal').classList.add('active');
        });
        
        // Cancel button in join modal
        document.getElementById('cancel-join-btn').addEventListener('click', () => {
            document.getElementById('join-modal').classList.remove('active');
            document.getElementById('join-room-id').value = '';
        });
        
        // Confirm button in join modal - actually join the room
        document.getElementById('confirm-join-btn').addEventListener('click', async () => {
            const username = document.getElementById('username').value.trim();
            const roomId = document.getElementById('join-room-id').value.trim();
            
            if (!username) {
                alert('Please enter a username');
                return;
            }
            
            // Validate room ID is 10 digits
            if (!roomId || roomId.length !== 10 || !/^\d+$/.test(roomId)) {
                alert('Please enter a valid 10-digit Room ID');
                return;
            }
            
            currentUsername = username;
            currentRoomId = roomId;
            localStorage.setItem('username', username);
            
            // Generate our own unique peer ID (not the room ID)
            const myUniquePeerId = `${roomId}-${generateRandomString()}`;
            
            // Initialize PeerJS with our unique ID
            peer = new Peer(myUniquePeerId, {
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                }
            });
            
            peer.on('open', async (id) => {
                myPeerId = id;
                console.log('My peer ID:', myPeerId);
                console.log('Connecting to room host:', roomId);
                
                // Setup PeerJS listeners first
                setupPeerListeners();
                
                // Connect to the room host (whose peer ID IS the room ID)
                hostConnection = peer.connect(roomId);
                
                hostConnection.on('open', () => {
                    console.log('Connected to room host!');
                    
                    // Request room data from host
                    hostConnection.send({
                        type: 'request-room-data',
                        username: currentUsername,
                        peerId: myPeerId
                    });
                });
                
                hostConnection.on('data', async (data) => {
                    console.log('Received from host:', data);
                    
                    if (data.type === 'room-data') {
                        // Receive room information from host
                        roomData = data.roomData;
                        currentRoomName = roomData.roomName;
                        
                        // Join the first channel
                        const channelIds = Object.keys(roomData.channels);
                        if (channelIds.length === 0) {
                            alert('Room has no channels');
                            return;
                        }
                        
                        currentChannelId = channelIds[0];
                        currentChannelName = roomData.channels[currentChannelId].name;
                        
                        // Get microphone access
                        try {
                            await getMicrophoneAccess();
                            
                            // Add ourselves to the channel
                            roomData.channels[currentChannelId].users.push({
                                peerId: myPeerId,
                                username: currentUsername
                            });
                            
                            // Tell host we joined
                            hostConnection.send({
                                type: 'user-joined',
                                peerId: myPeerId,
                                username: currentUsername,
                                channelId: currentChannelId
                            });
                            
                            // Connect to all existing users in channel
                            const existingUsers = data.usersToConnect || [];
                            for (const user of existingUsers) {
                                if (user.peerId !== myPeerId) {
                                    await connectToPeer(user.peerId, user.username);
                                }
                            }
                            
                            // Go to room screen
                            document.getElementById('join-modal').classList.remove('active');
                            document.getElementById('home-screen').style.display = 'none';
                            document.getElementById('room-screen').style.display = 'block';
                            document.getElementById('room-title-display').textContent = currentRoomName;
                            document.getElementById('header-room-id').textContent = currentRoomId;
                            
                            updateChannelsList();
                            updateUsersList();
                            addSystemMessage('Joined ' + currentChannelName);
                            
                        } catch (error) {
                            console.error('Error accessing microphone:', error);
                            alert('Could not access microphone. Please grant permission.');
                        }
                    }
                });
                
                hostConnection.on('error', (error) => {
                    console.error('Host connection error:', error);
                    alert('Could not connect to room. The room may not exist or the host may be offline.');
                });
            });
            
            peer.on('error', (error) => {
                console.error('Peer error:', error);
                alert('Connection error: ' + error.type);
            });
        });
        
        // ====================================================================
        // ROOM SETUP SCREEN - ENTER ROOM BUTTON
        // After creating a room and naming it, enter the actual room interface
        // ====================================================================
        
        // Make room ID clickable to copy
        document.getElementById('display-room-id').addEventListener('click', () => {
            const roomId = document.getElementById('display-room-id').textContent;
            navigator.clipboard.writeText(roomId).then(() => {
                alert('Room ID copied to clipboard!');
            });
        });
        
        // Make header room ID clickable to copy
        document.addEventListener('click', (e) => {
            if (e.target.id === 'header-room-id') {
                const roomId = document.getElementById('header-room-id').textContent;
                navigator.clipboard.writeText(roomId).then(() => {
                    alert('Room ID copied to clipboard!');
                });
            }
        });
        
        // Enter room button - validate room name and get mic access
        document.getElementById('enter-room-btn').addEventListener('click', async () => {
            const roomName = document.getElementById('room-name-input').value.trim();
            
            if (!roomName) {
                alert('Please enter a room name');
                return;
            }
            
            currentRoomName = roomName;
            roomData.roomName = roomName;
            
            // Get microphone access
            try {
                await getMicrophoneAccess();
                
                // Transition to main room screen
                document.getElementById('room-setup-screen').style.display = 'none';
                document.getElementById('room-screen').style.display = 'block';
                document.getElementById('room-title-display').textContent = roomName;
                document.getElementById('header-room-id').textContent = currentRoomId;
                
                updateChannelsList();
                updateUsersList();
                addSystemMessage('Welcome to ' + currentChannelName);
                
            } catch (error) {
                console.error('Error accessing microphone:', error);
                alert('Could not access microphone. Please grant permission and try again.');
            }
        });
        
        // ====================================================================
        // PEERJS EVENT LISTENERS
        // Setup listeners for incoming connections and data
        // ====================================================================
        
        function setupPeerListeners() {
            // When someone calls us with audio
            peer.on('call', (call) => {
                console.log('Incoming call from:', call.peer);
                
                // Answer the call with our audio stream
                call.answer(localStream);
                
                // When we receive their audio stream
                call.on('stream', (remoteStream) => {
                    console.log('Received stream from:', call.peer);
                    handleRemoteStream(call.peer, remoteStream);
                });
                
                // Store the call connection
                peerConnections[call.peer] = call;
            });
            
            // When someone sends us a data connection (for chat or room sync)
            peer.on('connection', (conn) => {
                console.log('Incoming data connection from:', conn.peer);
                setupDataConnection(conn);
            });
        }
        
        // ====================================================================
        // CONNECTING TO OTHER PEERS
        // Establish WebRTC connections for audio and data (chat)
        // ====================================================================
        
        async function connectToPeer(remotePeerId, remoteUsername) {
            console.log('Connecting to peer:', remotePeerId);
            
            // Setup data connection for chat messages
            const dataConn = peer.connect(remotePeerId);
            setupDataConnection(dataConn);
            
            // Setup audio call
            const call = peer.call(remotePeerId, localStream);
            
            call.on('stream', (remoteStream) => {
                console.log('Received stream from:', remotePeerId);
                handleRemoteStream(remotePeerId, remoteStream);
            });
            
            // Store connection
            peerConnections[remotePeerId] = call;
            
            // Add user to our local tracking
            usersInChannel[remotePeerId] = remoteUsername;
            updateUsersList();
        }
        
        // ====================================================================
        // DATA CONNECTION SETUP (FOR CHAT)
        // PeerJS data connections allow us to send chat messages and signals
        // ====================================================================
        
        function setupDataConnection(conn) {
            dataConnections[conn.peer] = conn;
            
            conn.on('open', () => {
                console.log('Data connection opened with:', conn.peer);
                
                // Send our username
                conn.send({
                    type: 'username',
                    username: currentUsername
                });
                
                // Notify about new user
                broadcastData({
                    type: 'user-joined',
                    peerId: myPeerId,
                    username: currentUsername
                });
            });
            
            conn.on('data', (data) => {
                handleDataMessage(conn.peer, data);
            });
            
            conn.on('close', () => {
                console.log('Data connection closed with:', conn.peer);
                delete dataConnections[conn.peer];
            });
        }
        
        // ====================================================================
        // HANDLING INCOMING DATA MESSAGES
        // Process different types of messages: chat, username, user-joined, etc.
        // ====================================================================
        
        function handleDataMessage(fromPeerId, data) {
            switch (data.type) {
                case 'request-room-data':
                    // A new user is requesting room data (only host receives this)
                    if (isHost) {
                        console.log('Sending room data to:', fromPeerId);
                        
                        // Get list of users in the first channel to connect to
                        const channelIds = Object.keys(roomData.channels);
                        const firstChannelId = channelIds[0];
                        const usersToConnect = roomData.channels[firstChannelId].users;
                        
                        // Send room data back
                        const conn = dataConnections[fromPeerId];
                        if (conn) {
                            conn.send({
                                type: 'room-data',
                                roomData: roomData,
                                usersToConnect: usersToConnect
                            });
                        }
                    }
                    break;
                    
                case 'chat':
                    // Display chat message
                    addChatMessage(data.username, data.message, data.timestamp, false);
                    break;
                    
                case 'username':
                    // Store username for this peer
                    usersInChannel[fromPeerId] = data.username;
                    updateUsersList();
                    break;
                    
                case 'user-joined':
                    // Another user joined the channel
                    console.log('User joined:', data.username, data.peerId);
                    usersInChannel[data.peerId] = data.username;
                    
                    // If we're the host, update room data
                    if (isHost && data.channelId && roomData.channels[data.channelId]) {
                        const existingUser = roomData.channels[data.channelId].users.find(u => u.peerId === data.peerId);
                        if (!existingUser) {
                            roomData.channels[data.channelId].users.push({
                                peerId: data.peerId,
                                username: data.username
                            });
                        }
                    }
                    
                    updateUsersList();
                    addSystemMessage(`${data.username} joined the channel`);
                    
                    // If we're already connected, establish connection
                    if (data.peerId !== myPeerId && !peerConnections[data.peerId]) {
                        connectToPeer(data.peerId, data.username);
                    }
                    break;
                    
                case 'user-left':
                    // User left the channel
                    delete usersInChannel[data.peerId];
                    updateUsersList();
                    addSystemMessage(`${data.username} left the channel`);
                    
                    // Close connections
                    if (peerConnections[data.peerId]) {
                        peerConnections[data.peerId].close();
                        delete peerConnections[data.peerId];
                    }
                    if (dataConnections[data.peerId]) {
                        dataConnections[data.peerId].close();
                        delete dataConnections[data.peerId];
                    }
                    if (remoteAudioElements[data.peerId]) {
                        remoteAudioElements[data.peerId].remove();
                        delete remoteAudioElements[data.peerId];
                    }
                    break;
                    
                case 'channel-created':
                    // New channel was created
                    roomData.channels[data.channelId] = {
                        name: data.channelName,
                        users: []
                    };
                    updateChannelsList();
                    addSystemMessage(`Channel "${data.channelName}" created`);
                    break;
                    
                case 'channel-deleted':
                    // Channel was deleted
                    if (currentChannelId === data.channelId) {
                        // We were in this channel, move to first available
                        const otherChannels = Object.keys(roomData.channels).filter(id => id !== data.channelId);
                        if (otherChannels.length > 0) {
                            switchChannel(otherChannels[0]);
                        }
                    }
                    delete roomData.channels[data.channelId];
                    updateChannelsList();
                    break;
                    
                case 'host-transfer':
                    // Host role transferred
                    isHost = (data.newHost === myPeerId);
                    roomData.host = data.newHost;
                    updateChannelsList();
                    addSystemMessage(`${data.username} is now the host`);
                    break;
            }
        }
        
        // ====================================================================
        // MICROPHONE ACCESS
        // Request permission and access to user's microphone
        // ====================================================================
        
        async function getMicrophoneAccess() {
            const constraints = {
                audio: {
                    deviceId: selectedMicDeviceId ? { exact: selectedMicDeviceId } : undefined,
                    echoCancellation: true,
                    noiseSuppression: noiseSuppressionEnabled,
                    autoGainControl: true
                }
            };
            
            localStream = await navigator.mediaDevices.getUserMedia(constraints);
            
            // If PTT is enabled, mute by default
            if (pushToTalkEnabled) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = false;
                });
            }
            
            // Enumerate available audio devices
            await enumerateAudioDevices();
        }
        
        // Get list of available microphones and populate dropdown
        async function enumerateAudioDevices() {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const audioInputs = devices.filter(d => d.kind === 'audioinput');
            
            const select = document.getElementById('mic-input-select');
            select.innerHTML = '';
            
            audioInputs.forEach(device => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                option.textContent = device.label || `Microphone ${select.children.length + 1}`;
                select.appendChild(option);
            });
            
            if (selectedMicDeviceId) {
                select.value = selectedMicDeviceId;
            }
        }
        
        // ====================================================================
        // HANDLING REMOTE AUDIO STREAMS
        // When we receive audio from another user, create an <audio> element
        // ====================================================================
        
        function handleRemoteStream(peerId, stream) {
            // Create audio element to play remote user's audio
            const audio = document.createElement('audio');
            audio.srcObject = stream;
            audio.autoplay = true;
            audio.id = `audio-${peerId}`;
            document.body.appendChild(audio);
            
            remoteAudioElements[peerId] = audio;
            
            // Apply volume settings
            const userVolume = userVolumes[peerId] || 100;
            audio.volume = (userVolume / 100) * (outputVolume / 100);
        }
        
        // ====================================================================
        // CHANNELS MANAGEMENT
        // Creating, deleting, and switching between voice channels
        // ====================================================================
        
        // Update the channels list in the UI
        function updateChannelsList() {
            const channelList = document.getElementById('channel-list');
            channelList.innerHTML = '';
            
            Object.keys(roomData.channels).forEach(channelId => {
                const channel = roomData.channels[channelId];
                const channelItem = document.createElement('div');
                channelItem.className = 'channel-item' + (channelId === currentChannelId ? ' active' : '');
                
                const channelName = document.createElement('span');
                channelName.className = 'channel-name';
                channelName.textContent = '# ' + channel.name;
                
                channelItem.appendChild(channelName);
                
                // Show delete button if host and not the only channel
                if (isHost && Object.keys(roomData.channels).length > 1) {
                    const deleteBtn = document.createElement('span');
                    deleteBtn.className = 'channel-delete';
                    deleteBtn.textContent = 'Ã—';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteChannel(channelId);
                    };
                    channelItem.appendChild(deleteBtn);
                }
                
                channelItem.onclick = () => switchChannel(channelId);
                
                channelList.appendChild(channelItem);
            });
        }
        
        // Add new channel button (host only)
        document.getElementById('add-channel-btn').addEventListener('click', () => {
            if (!isHost) {
                alert('Only the host can create channels');
                return;
            }
            
            const channelName = prompt('Enter channel name:');
            if (channelName && channelName.trim()) {
                const channelId = generateChannelId();
                
                // Create channel
                roomData.channels[channelId] = {
                    name: channelName.trim(),
                    users: []
                };
                
                updateChannelsList();
                
                // Notify all peers
                broadcastData({
                    type: 'channel-created',
                    channelId: channelId,
                    channelName: channelName.trim()
                });
            }
        });
        
        // Switch to a different channel
        function switchChannel(channelId) {
            if (channelId === currentChannelId) return;
            
            // Remove ourselves from old channel
            const oldChannel = roomData.channels[currentChannelId];
            if (oldChannel) {
                oldChannel.users = oldChannel.users.filter(u => u.peerId !== myPeerId);
            }
            
            // Add ourselves to new channel
            const newChannel = roomData.channels[channelId];
            if (newChannel) {
                newChannel.users.push({
                    peerId: myPeerId,
                    username: currentUsername
                });
            }
            
            // Close all existing connections
            Object.keys(peerConnections).forEach(peerId => {
                if (peerConnections[peerId]) {
                    peerConnections[peerId].close();
                    delete peerConnections[peerId];
                }
            });
            
            Object.keys(dataConnections).forEach(peerId => {
                if (dataConnections[peerId]) {
                    dataConnections[peerId].close();
                    delete dataConnections[peerId];
                }
            });
            
            Object.keys(remoteAudioElements).forEach(peerId => {
                if (remoteAudioElements[peerId]) {
                    remoteAudioElements[peerId].remove();
                    delete remoteAudioElements[peerId];
                }
            });
            
            // Update current channel
            currentChannelId = channelId;
            currentChannelName = newChannel.name;
            usersInChannel = {};
            
            // Connect to users in new channel
            newChannel.users.forEach(user => {
                if (user.peerId !== myPeerId) {
                    connectToPeer(user.peerId, user.username);
                }
            });
            
            updateChannelsList();
            updateUsersList();
            clearChat();
            addSystemMessage('Switched to ' + currentChannelName);
        }
        
        // Delete a channel (host only)
        function deleteChannel(channelId) {
            if (!isHost) {
                alert('Only the host can delete channels');
                return;
            }
            
            if (Object.keys(roomData.channels).length <= 1) {
                alert('Cannot delete the last channel');
                return;
            }
            
            if (confirm('Delete this channel? Users will be moved to another channel.')) {
                // Move users to another channel
                const otherChannelIds = Object.keys(roomData.channels).filter(id => id !== channelId);
                const targetChannelId = otherChannelIds[0];
                
                const usersToMove = roomData.channels[channelId].users;
                usersToMove.forEach(user => {
                    roomData.channels[targetChannelId].users.push(user);
                });
                
                // Delete channel
                delete roomData.channels[channelId];
                
                // Notify all peers
                broadcastData({
                    type: 'channel-deleted',
                    channelId: channelId
                });
                
                updateChannelsList();
            }
        }
        
        // ====================================================================
        // USERS LIST
        // Display all users in the current voice channel
        // ====================================================================
        
        function updateUsersList() {
            const userList = document.getElementById('user-list');
            userList.innerHTML = '';
            
            // Add ourselves
            addUserToList(myPeerId, currentUsername + ' (You)', true);
            
            // Add other users
            Object.keys(usersInChannel).forEach(peerId => {
                if (peerId !== myPeerId) {
                    addUserToList(peerId, usersInChannel[peerId], false);
                }
            });
        }
        
        function addUserToList(peerId, username, isMe) {
            const userList = document.getElementById('user-list');
            
            const userItem = document.createElement('div');
            userItem.className = 'user-item';
            userItem.dataset.peerId = peerId;
            
            const statusIcon = document.createElement('span');
            statusIcon.className = 'user-status-icon';
            statusIcon.textContent = 'ðŸ”Š'; // Default unmuted
            
            const userName = document.createElement('span');
            userName.className = 'user-name';
            userName.textContent = username;
            
            userItem.appendChild(statusIcon);
            userItem.appendChild(userName);
            
            // Add context menu for other users (not ourselves)
            if (!isMe) {
                userItem.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showUserContextMenu(e, peerId);
                });
                
                userItem.addEventListener('click', (e) => {
                    showUserContextMenu(e, peerId);
                });
            }
            
            userList.appendChild(userItem);
        }
        
        // ====================================================================
        // USER CONTEXT MENU
        // Right-click menu for adjusting individual user volumes
        // ====================================================================
        
        function showUserContextMenu(event, peerId) {
            const menu = document.getElementById('user-context-menu');
            contextMenuTargetUserId = peerId;
            
            // Position menu at mouse location
            menu.style.left = event.clientX + 'px';
            menu.style.top = event.clientY + 'px';
            menu.classList.add('active');
            
            // Set current volume for this user
            const volume = userVolumes[peerId] || 100;
            document.getElementById('user-volume-slider').value = volume;
            document.getElementById('user-volume-value').textContent = volume + '%';
        }
        
        // Close context menu when clicking outside
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('user-context-menu');
            if (!menu.contains(e.target) && !e.target.closest('.user-item')) {
                menu.classList.remove('active');
            }
        });
        
        // User volume slider in context menu
        document.getElementById('user-volume-slider').addEventListener('input', (e) => {
            const volume = parseInt(e.target.value);
            document.getElementById('user-volume-value').textContent = volume + '%';
            
            if (contextMenuTargetUserId) {
                userVolumes[contextMenuTargetUserId] = volume;
                
                // Apply volume to audio element
                if (remoteAudioElements[contextMenuTargetUserId]) {
                    remoteAudioElements[contextMenuTargetUserId].volume = (volume / 100) * (outputVolume / 100);
                }
                
                // Save settings
                saveSettings();
            }
        });
        
        // ====================================================================
        // CHAT FUNCTIONALITY
        // Sending and receiving text messages with timestamp
        // ====================================================================
        
        // Send message on Enter key
        document.getElementById('chat-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendChatMessage();
            }
        });
        
        function sendChatMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();
            
            if (!message) return;
            
            const timestamp = new Date().toISOString();
            
            // Add to our own chat
            addChatMessage(currentUsername, message, timestamp, true);
            
            // Broadcast to all connected peers
            broadcastData({
                type: 'chat',
                username: currentUsername,
                message: message,
                timestamp: timestamp
            });
            
            input.value = '';
        }
        
        // Add a chat message to the display
        function addChatMessage(username, message, timestamp, isOwnMessage) {
            const messagesDiv = document.getElementById('chat-messages');
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message';
            
            // Message header with username and timestamp
            const header = document.createElement('div');
            header.className = 'message-header';
            
            const usernameSpan = document.createElement('span');
            usernameSpan.className = 'message-username';
            usernameSpan.textContent = username;
            
            const timestampSpan = document.createElement('span');
            timestampSpan.className = 'message-timestamp';
            timestampSpan.textContent = formatTimestamp(timestamp);
            
            header.appendChild(usernameSpan);
            header.appendChild(timestampSpan);
            
            // Message text with link/image processing
            const textDiv = document.createElement('div');
            textDiv.className = 'message-text';
            textDiv.innerHTML = processMessageContent(message);
            
            messageDiv.appendChild(header);
            messageDiv.appendChild(textDiv);
            
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        // Add system messages (user joined, channel switched, etc.)
        function addSystemMessage(message) {
            const messagesDiv = document.getElementById('chat-messages');
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message';
            messageDiv.style.background = '#2f3136';
            messageDiv.style.fontStyle = 'italic';
            messageDiv.style.color = '#72767d';
            messageDiv.textContent = message;
            
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        function clearChat() {
            document.getElementById('chat-messages').innerHTML = '';
        }
        
        // Format ISO timestamp to hh:mm:ss AM/PM
        function formatTimestamp(isoString) {
            const date = new Date(isoString);
            let hours = date.getHours();
            const minutes = date.getMinutes().toString().padStart(2, '0');
            const seconds = date.getSeconds().toString().padStart(2, '0');
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12 || 12;
            
            return `${hours}:${minutes}:${seconds} ${ampm}`;
        }
        
        // Process message content to detect and embed URLs and images
        function processMessageContent(message) {
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            
            return message.replace(urlRegex, (url) => {
                // Check if it's an image/GIF
                if (url.match(/\.(gif|png|jpg|jpeg|webp)$/i)) {
                    return `<a href="${url}" target="_blank">${url}</a><br><img src="${url}" alt="Image">`;
                } else {
                    return `<a href="${url}" target="_blank">${url}</a>`;
                }
            });
        }
        
        // Broadcast data to all connected peers
        function broadcastData(data) {
            Object.values(dataConnections).forEach(conn => {
                if (conn.open) {
                    conn.send(data);
                }
            });
        }
        
        // ====================================================================
        // BOTTOM CONTROLS - SETTINGS, MIC, LEAVE
        // Event handlers for the control buttons
        // ====================================================================
        
        document.getElementById('settings-btn').addEventListener('click', () => {
            document.getElementById('settings-modal').classList.add('active');
        });
        
        document.getElementById('close-settings-btn').addEventListener('click', () => {
            document.getElementById('settings-modal').classList.remove('active');
            saveSettings();
        });
        
        document.getElementById('mic-btn').addEventListener('click', () => {
            document.getElementById('settings-modal').classList.add('active');
        });
        
        document.getElementById('leave-btn').addEventListener('click', () => {
            if (confirm('Are you sure you want to leave this room?')) {
                leaveRoom();
            }
        });
        
        // ====================================================================
        // SETTINGS - MICROPHONE SELECTION
        // Change microphone device on the fly
        // ====================================================================
        
        document.getElementById('mic-input-select').addEventListener('change', async (e) => {
            selectedMicDeviceId = e.target.value;
            
            // Stop current stream
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            
            try {
                // Get new stream with selected device
                await getMicrophoneAccess();
                
                // Replace tracks in all peer connections
                Object.values(peerConnections).forEach(call => {
                    const sender = call.peerConnection.getSenders().find(s => s.track?.kind === 'audio');
                    if (sender) {
                        sender.replaceTrack(localStream.getAudioTracks()[0]);
                    }
                });
                
                saveSettings();
            } catch (error) {
                console.error('Error changing microphone:', error);
                alert('Could not change microphone');
            }
        });
        
        // ====================================================================
        // SETTINGS - INPUT VOLUME
        // Adjust microphone input volume
        // ====================================================================
        
        document.getElementById('input-volume-slider').addEventListener('input', (e) => {
            inputVolume = parseInt(e.target.value);
            document.getElementById('input-volume-value').textContent = inputVolume + '%';
            saveSettings();
        });
        
        // ====================================================================
        // SETTINGS - OUTPUT VOLUME
        // Master volume for all incoming audio
        // ====================================================================
        
        document.getElementById('output-volume-slider').addEventListener('input', (e) => {
            outputVolume = parseInt(e.target.value);
            document.getElementById('output-volume-value').textContent = outputVolume + '%';
            
            // Apply to all remote audio elements
            Object.keys(remoteAudioElements).forEach(peerId => {
                const userVolume = userVolumes[peerId] || 100;
                remoteAudioElements[peerId].volume = (userVolume / 100) * (outputVolume / 100);
            });
            
            saveSettings();
        });
        
        // ====================================================================
        // SETTINGS - NOISE SUPPRESSION
        // Toggle noise cancellation on/off
        // ====================================================================
        
        document.getElementById('noise-suppression-checkbox').addEventListener('change', async (e) => {
            noiseSuppressionEnabled = e.target.checked;
            
            // Restart stream with new settings
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            
            try {
                await getMicrophoneAccess();
                
                // Replace tracks in peer connections
                Object.values(peerConnections).forEach(call => {
                    const sender = call.peerConnection.getSenders().find(s => s.track?.kind === 'audio');
                    if (sender) {
                        sender.replaceTrack(localStream.getAudioTracks()[0]);
                    }
                });
                
                saveSettings();
            } catch (error) {
                console.error('Error updating noise suppression:', error);
            }
        });
        
        // ====================================================================
        // SETTINGS - PUSH TO TALK
        // Enable PTT mode and capture key binding
        // ====================================================================
        
        document.getElementById('ptt-checkbox').addEventListener('change', (e) => {
            pushToTalkEnabled = e.target.checked;
            
            if (pushToTalkEnabled) {
                // Show PTT key capture box
                document.getElementById('ptt-key-section').style.display = 'block';
                
                // Mute by default when PTT is enabled
                if (localStream) {
                    localStream.getAudioTracks().forEach(track => {
                        track.enabled = false;
                    });
                }
            } else {
                // Hide PTT section
                document.getElementById('ptt-key-section').style.display = 'none';
                
                // Unmute when PTT is disabled
                if (localStream) {
                    localStream.getAudioTracks().forEach(track => {
                        track.enabled = true;
                    });
                }
            }
            
            saveSettings();
        });
        
        // PTT key capture
        let capturingPTTKey = false;
        
        document.getElementById('ptt-keybox').addEventListener('click', () => {
            if (capturingPTTKey) return;
            
            capturingPTTKey = true;
            const keybox = document.getElementById('ptt-keybox');
            keybox.textContent = 'Press any key or mouse button...';
            keybox.style.background = '#5865f2';
        });
        
        // Capture keyboard key for PTT
        document.addEventListener('keydown', (e) => {
            if (capturingPTTKey) {
                e.preventDefault();
                pushToTalkKey = { type: 'keyboard', key: e.key, code: e.code };
                
                const keybox = document.getElementById('ptt-keybox');
                keybox.textContent = `PTT Key: ${e.key}`;
                keybox.style.background = '#2f3136';
                capturingPTTKey = false;
                saveSettings();
                return;
            }
            
            // Handle PTT activation
            if (pushToTalkEnabled && pushToTalkKey && pushToTalkKey.type === 'keyboard' && e.code === pushToTalkKey.code) {
                e.preventDefault();
                activatePushToTalk();
            }
        });
        
        // Handle PTT deactivation on key release
        document.addEventListener('keyup', (e) => {
            if (pushToTalkEnabled && pushToTalkKey && pushToTalkKey.type === 'keyboard' && e.code === pushToTalkKey.code) {
                e.preventDefault();
                deactivatePushToTalk();
            }
        });
        
        // Capture mouse button for PTT
        document.addEventListener('mousedown', (e) => {
            if (capturingPTTKey) {
                e.preventDefault();
                pushToTalkKey = { type: 'mouse', button: e.button };
                
                const keybox = document.getElementById('ptt-keybox');
                keybox.textContent = `PTT Key: Mouse Button ${e.button}`;
                keybox.style.background = '#2f3136';
                capturingPTTKey = false;
                saveSettings();
                return;
            }
            
            // Handle PTT activation
            if (pushToTalkEnabled && pushToTalkKey && pushToTalkKey.type === 'mouse' && e.button === pushToTalkKey.button) {
                e.preventDefault();
                activatePushToTalk();
            }
        });
        
        // Handle PTT deactivation on mouse release
        document.addEventListener('mouseup', (e) => {
            if (pushToTalkEnabled && pushToTalkKey && pushToTalkKey.type === 'mouse' && e.button === pushToTalkKey.button) {
                e.preventDefault();
                deactivatePushToTalk();
            }
        });
        
        // Activate push-to-talk (unmute)
        function activatePushToTalk() {
            if (isPushToTalkActive) return;
            
            isPushToTalkActive = true;
            
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = true;
                });
            }
        }
        
        // Deactivate push-to-talk (mute)
        function deactivatePushToTalk() {
            if (!isPushToTalkActive) return;
            
            isPushToTalkActive = false;
            
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = false;
                });
            }
        }
        
        // ====================================================================
        // SETTINGS PERSISTENCE
        // Save and load settings from localStorage
        // ====================================================================
        
        function saveSettings() {
            const settings = {
                selectedMicDeviceId,
                inputVolume,
                outputVolume,
                noiseSuppressionEnabled,
                pushToTalkEnabled,
                pushToTalkKey,
                userVolumes
            };
            
            localStorage.setItem('voiceChatSettings', JSON.stringify(settings));
        }
        
        function loadSettings() {
            const saved = localStorage.getItem('voiceChatSettings');
            if (!saved) return;
            
            const settings = JSON.parse(saved);
            
            selectedMicDeviceId = settings.selectedMicDeviceId || null;
            inputVolume = settings.inputVolume || 100;
            outputVolume = settings.outputVolume || 100;
            noiseSuppressionEnabled = settings.noiseSuppressionEnabled || false;
            pushToTalkEnabled = settings.pushToTalkEnabled || false;
            pushToTalkKey = settings.pushToTalkKey || null;
            userVolumes = settings.userVolumes || {};
            
            // Apply settings to UI
            document.getElementById('input-volume-slider').value = inputVolume;
            document.getElementById('input-volume-value').textContent = inputVolume + '%';
            document.getElementById('output-volume-slider').value = outputVolume;
            document.getElementById('output-volume-value').textContent = outputVolume + '%';
            document.getElementById('noise-suppression-checkbox').checked = noiseSuppressionEnabled;
            document.getElementById('ptt-checkbox').checked = pushToTalkEnabled;
            
            if (pushToTalkEnabled && pushToTalkKey) {
                document.getElementById('ptt-key-section').style.display = 'block';
                const keybox = document.getElementById('ptt-keybox');
                if (pushToTalkKey.type === 'keyboard') {
                    keybox.textContent = `PTT Key: ${pushToTalkKey.key}`;
                } else {
                    keybox.textContent = `PTT Key: Mouse Button ${pushToTalkKey.button}`;
                }
            }
        }
        
        // ====================================================================
        // ROOM DATA MANAGEMENT
        // Save and load room data from localStorage
        // ====================================================================
        
        function saveRoomData() {
            localStorage.setItem(`room_${currentRoomId}`, JSON.stringify(roomData));
        }
        
        // ====================================================================
        // LEAVE ROOM
        // Clean up connections and return to home screen
        // ====================================================================
        
        function leaveRoom() {
            // Notify others we're leaving
            broadcastData({
                type: 'user-left',
                peerId: myPeerId,
                username: currentUsername
            });
            
            // Remove ourselves from room data
            if (roomData.channels[currentChannelId]) {
                roomData.channels[currentChannelId].users = 
                    roomData.channels[currentChannelId].users.filter(u => u.peerId !== myPeerId);
            }
            
            // Check if we need to transfer host
            if (isHost) {
                const allUsers = [];
                Object.values(roomData.channels).forEach(channel => {
                    allUsers.push(...channel.users);
                });
                
                if (allUsers.length > 0) {
                    // Transfer host to first user
                    const newHost = allUsers[0];
                    roomData.host = newHost.peerId;
                    
                    broadcastData({
                        type: 'host-transfer',
                        newHost: newHost.peerId,
                        username: newHost.username
                    });
                }
                // If no users left, room will naturally cease to exist
            }
            
            // Stop local stream
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            // Close all peer connections
            Object.values(peerConnections).forEach(call => {
                call.close();
            });
            peerConnections = {};
            
            // Close all data connections
            Object.values(dataConnections).forEach(conn => {
                conn.close();
            });
            dataConnections = {};
            
            // Close host connection if we have one
            if (hostConnection) {
                hostConnection.close();
                hostConnection = null;
            }
            
            // Remove remote audio elements
            Object.values(remoteAudioElements).forEach(audio => {
                audio.remove();
            });
            remoteAudioElements = {};
            
            // Destroy peer
            if (peer) {
                peer.destroy();
                peer = null;
            }
            
            // Reset state
            currentRoomId = '';
            currentRoomName = '';
            currentChannelId = '';
            currentChannelName = '';
            isHost = false;
            roomData = {};
            usersInChannel = {};
            
            // Return to home screen
            document.getElementById('room-screen').style.display = 'none';
            document.getElementById('room-setup-screen').style.display = 'none';
            document.getElementById('home-screen').style.display = 'flex';
        }
        
        // ====================================================================
        // UTILITY FUNCTIONS
        // Helper functions for generating IDs and random strings
        // ====================================================================
        
        // Generate a unique 10-digit room ID
        function generateRoomId() {
            return Math.floor(1000000000 + Math.random() * 9000000000).toString();
        }
        
        // Generate a random channel ID
        function generateChannelId() {
            return 'channel_' + Math.random().toString(36).substring(2, 9);
        }
        
        // Generate a random string for peer IDs
        function generateRandomString() {
            return Math.random().toString(36).substring(2, 9);
        }
    </script>
</body>
</html>
